/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : EEPROM.c
**     Project     : ccTalk RS232
**     Processor   : MC9S08PA16VLC
**     Component   : IntEEPROM
**     Version     : Component 02.218, Driver 01.00, CPU db: 3.00.000
**     Compiler    : CodeWarrior HCS08 C Compiler
**     Date/Time   : 2015-02-07, 00:53, # CodeGen: 9
**     Abstract    :
**         This device "IntEEPROM" implements internal EEPROM
**     Settings    :
**         Virtual page size           : 10 byte
**         Initialization:
**              Wait in methods        : Enabled
**              EEPROM clock           : 1000 kHz
**
**     Contents    :
**         SetByte     - byte EEPROM_SetByte(EEPROM_TAddress Addr, byte Data);
**         GetByte     - byte EEPROM_GetByte(EEPROM_TAddress Addr, byte *Data);
**         SetBytePage - byte EEPROM_SetBytePage(word Index, byte Data);
**         GetBytePage - byte EEPROM_GetBytePage(word Index, byte *Data);
**         SetPage     - byte EEPROM_SetPage(EEPROM_TAddress Addr);
**         GetPage     - byte EEPROM_GetPage(EEPROM_TAddress Addr);
**
**     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file EEPROM.c
** @version 01.00
** @brief
**         This device "IntEEPROM" implements internal EEPROM
*/         
/*!
**  @addtogroup EEPROM_module EEPROM module documentation
**  @{
*/         


/* MODULE EEPROM. */

#include "EEPROM.h"

/* Internal type for addressing of the EEPROM. */
typedef const  byte *  EEPROM_TAddress_; /* Type of address to the EEPROM */

/*lint -save  -e923 -e926 -e927 -e928 -e929 Disable MISRA rule (11.3,11.4) checking. */

static byte Page[EEPROM_VIRTUAL_PAGE_SIZE]; /* Virtual page */
static byte BackupArray[0x02];         /* Array for backup data from erased sector */

/*
** ===================================================================
**     Method      :  BackupSector (component IntEEPROM)
**
**     Description :
**         The method backups the content of a sector being erased.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void BackupSector(EEPROM_TAddress_ Addr, word From, word To)
{
  word i;

  for (i = From; i < To; i = i + 1U) {
    BackupArray[i] = *(byte *) (Addr + i); /* save one sector to RAM */
  }
}

/*
** ===================================================================
**     Method      :  WriteBlock (component IntEEPROM)
**
**     Description :
**         The method writes the block of data to EEPROM memory.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte WriteBlock(EEPROM_TAddress Addr, word From, word To, const byte* Data)
{
  byte err = 0U;
  word i;
  byte j;
  word PhraseAddr;

  if(From == To) {
    return ERR_OK;
  }
  i = From;
  PhraseAddr = (word)Addr;
  while(i < To) {
  /* NVM_FSTAT: ACCERR=1,FPVIOL=1 */
    NVM_FSTAT = 0x30U;                 /* Clear error flags */
    NVM_FCCOBIX = 0U;                  /* Clear index register */
    NVM_FCCOBHI = 0x11U;               /* Program D-Flash command */
    NVM_FCCOBLO = 0U;                  /* High address word */
    NVM_FCCOBIX++;                     /* Shift index register */
    NVM_FCCOB = (word)PhraseAddr;      /* Low address word */
    for(j = 0U;j < 4U;j += 1U) {
      NVM_FCCOBIX++;                   /* Shift index register */
      NVM_FCCOBLO = *(const byte*)(Data + (i)); /* Load new data */
      i += 1U;
      if(i >= To) {break;}
    }
    NVM_FSTAT = 0x80U;                 /* Clear flag command buffer empty */
    while (NVM_FSTAT_CCIF == 0U) {     /* Wait to command complete */
      EnterCritical();
      WDOG_CNT = 0xA602U;              /* Reset watchdog counter write 0xA602, 0xB480 */
      WDOG_CNT = 0xB480U;
      ExitCritical();
    }
    if ((NVM_FSTAT & 0x30U) != 0U) {   /* Is protection violation or access error detected ? */
      return ERR_NOTAVAIL;             /* If yes then error */
    }
    if (NVM_FSTAT_MGSTAT) {            /* Was attempt to write data to the given address erroneous? */
      err = 1U;                        /* If yes then mark an error */
    }
    PhraseAddr += 4U;
  }
  if(err != 0U) {
    return ERR_VALUE;                  /* If yes then error */
  }
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  EraseSectorInternal (component IntEEPROM)
**
**     Description :
**         The method erase a specific sector.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte EraseSectorInternal(EEPROM_TAddress Addr)
{
  if (NVM_FSTAT_CCIF == 0U) {          /* Is command complete ? */
    return ERR_BUSY;                   /* If yes then error */
  }
  /* NVM_FSTAT: ACCERR=1,FPVIOL=1 */
  NVM_FSTAT = 0x30U;                   /* Clear error flags */
  NVM_FCCOBIX = 0U;                    /* Clear index register */
  NVM_FCCOBHI = 0x12U;                 /* Erase D-Flash sector command */
  NVM_FCCOBLO = 0U;                    /* High address word */
  NVM_FCCOBIX++;                       /* Shift index register */
  NVM_FCCOB = (word)Addr;              /* Low address word */
  NVM_FSTAT = 0x80U;                   /* Clear flag command buffer empty */
  while (NVM_FSTAT_CCIF == 0U) {       /* Wait to command complete */
    EnterCritical();
    WDOG_CNT = 0xA602U;                /* Reset watchdog counter write 0xA602, 0xB480 */
    WDOG_CNT = 0xB480U;
    ExitCritical();
  }
  if ((NVM_FSTAT & 0x23U) != 0U) {     /* Is access error or other error detected ? */
    return ERR_NOTAVAIL;               /* If yes then error */
  }
  return ERR_OK;                       /* OK */
}
/*
** ===================================================================
**     Method      :  EEPROM_SetByte (component IntEEPROM)
**     Description :
**         This method writes a given byte to a specified address in
**         EEPROM. The method also sets address pointer for <SetActByte>
**         and <GetActByte> methods (applicable only if these methods
**         are enabled). The pointer is set to address passed as the
**         parameter.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Addr            - Address to EEPROM
**         Data            - Data to write
**     Returns     :
**         ---             - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_SPEED - the component does not work
**                           in the active speed mode 
**                           - ERR_BUSY - device is busy 
**                           - ERR_VALUE - verification of written data
**                           failed (read value does not match with
**                           written value) 
**                           - ERR_NOTAVAIL - other device-specific
**                           error 
**                           - ERR_RANGE - parameter Addr is out of range
** ===================================================================
*/
byte EEPROM_SetByte(EEPROM_TAddress Addr,byte Data)
{
  byte err;
  EEPROM_TAddress SecAddr;             /* EEPROM Sector address */

  if(((word)Addr < (word)EEPROM_AREA_START) || ((word)Addr > (word)EEPROM_AREA_END)) { /* Is given address out of EEPROM area array ? */
    return ERR_RANGE;                  /* If yes then error */
  }
  if(!NVM_FSTAT_CCIF) {                /* Is reading from EEPROM possible? */
    return ERR_BUSY;                   /* If no then error */
  }
  if (*(Addr) == 0xFFU) {              /* Is the byte erased? */
    err = WriteBlock(Addr, 0U, 1U, &Data); /* Write new data */
  } else {                             /* Is given address non-erased ? */
    SecAddr = (EEPROM_TAddress)((word)Addr & 0xFFFEU); /* Sector Aligned address */
    BackupSector(SecAddr, 0U, 0x02U);  /* Backup sector */
    BackupArray[(((word)Addr) % 0x02U)] = Data; /* Write new data to saved sector */
    err = EraseSectorInternal(Addr);   /* Erase sector */
    if(err != 0U) {
      return(err);                     /* Return error code if previous operation finished not correctly */
    }
    err = WriteBlock(SecAddr, 0U, 0x02U,BackupArray); /* Restore sector */
  }
  return(err);
}

/*
** ===================================================================
**     Method      :  EEPROM_GetByte (component IntEEPROM)
**     Description :
**         This method reads a byte from a specified EEPROM address.
**         The method also sets address pointer for <SetActByte> and
**         <GetActByte> methods (applicable only if these methods are
**         enabled). The pointer is set to address passed as the
**         parameter.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Addr            - EEPROM Address
**       * Data            - A pointer to the returned 8-bit data
**     Returns     :
**         ---             - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_BUSY - device is busy 
**                           - ERR_RANGE - parameter Addr is out of range
** ===================================================================
*/
byte EEPROM_GetByte(EEPROM_TAddress Addr,byte *Data)
{
  if(((word)Addr < (word)EEPROM_AREA_START) || ((word)Addr > (word)EEPROM_AREA_END)) { /* Is given address out of EEPROM area array ? */
    return ERR_RANGE;                  /* If yes then error */
  }
  if(!NVM_FSTAT_CCIF) {                /* Is reading from EEPROM possible? */
    return ERR_BUSY;                   /* If no then error */
  }
  *Data = *((byte *)Addr);
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  EEPROM_SetBytePage (component IntEEPROM)
**     Description :
**         This method writes a given byte to a virtual page.
**         This method is only available when the <Page size> property
**         is set to a non-zero size of the virtual page. The method
**         also sets index pointer for <SetActBytePage> and
**         <GetActBytePage> methods (applicable only if these methods
**         are enabled).
**     Parameters  :
**         NAME            - DESCRIPTION
**         Index           - Index to page within the range 0 to
**                           (<Page size> - 1)
**         Data            - Data to write
**     Returns     :
**         ---             - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_RANGE - parameter Index is out of
**                           range
** ===================================================================
*/
byte EEPROM_SetBytePage(word Index,byte Data)
{
  if (Index > (EEPROM_VIRTUAL_PAGE_SIZE - 1U)) { /* Is given index out of virtual page? */
    return ERR_RANGE;                  /* If yes then error */
  }
  Page[Index] = Data;                  /* Write data to the virtual page (index used) */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  EEPROM_GetBytePage (component IntEEPROM)
**     Description :
**         This method reads a byte from a virtual page.
**         This method is only available when the <Page size> property
**         is set to a non-zero size of the virtual page. The method
**         also sets index pointer for <SetActBytePage> and
**         <GetActBytePage> methods (applicable only if these methods
**         are enabled).
**     Parameters  :
**         NAME            - DESCRIPTION
**         Index           - Index to page within the range 0 to
**                           (<Page size> - 1)
**       * Data            - A pointer to the returned 8-bit data
**     Returns     :
**         ---             - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_RANGE - parameter Index is out of
**                           range
** ===================================================================
*/
byte EEPROM_GetBytePage(word Index,byte *Data)
{
  if (Index > (EEPROM_VIRTUAL_PAGE_SIZE - 1U)) { /* Is the given index out of virtual page? */
    return ERR_RANGE;                  /* If yes then error */
  }
  *Data = Page[Index];                 /* Return data from virtual page (index used) */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  EEPROM_SetPage (component IntEEPROM)
**     Description :
**         This method writes the virtual page to EEPROM.
**         This method is enabled only if the <Page size> property is
**         set to a non-zero value. The method also sets address
**         pointer for <SetActByte> and <GetActByte> methods
**         (applicable only if these methods are enabled). The pointer
**         is set to address passed as the parameter + "Page size" - 1.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Addr            - Address in EEPROM
**     Returns     :
**         ---             - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_SPEED - the component does not work
**                           in the active speed mode 
**                           - ERR_BUSY - device is busy 
**                           - ERR_VALUE - source value is different
**                           from dest. value 
**                           - ERR_NOTAVAIL - other device-specific
**                           error 
**                           - ERR_RANGE - selected address out of the
**                           selected address range
** ===================================================================
*/
byte EEPROM_SetPage(EEPROM_TAddress Addr)
{
  EEPROM_TAddress SecAddr;             /* EEPROM sector address */
  byte err;                            /* Temporary variables */
  word j;

                                       /* Does the virtual page length exceed range of EEPROM
                                          according to the given starting address of writing? */
  if (((word)Addr < (word)EEPROM_AREA_START) || (((word)Addr + EEPROM_VIRTUAL_PAGE_SIZE) > ((word)EEPROM_AREA_END + 1U))) {
    return ERR_RANGE;                  /* If yes then error */
  }
  if(!NVM_FSTAT_CCIF) {                /* Is reading from EEPROM possible? */
    return ERR_BUSY;                   /* If no then error */
  }
  if ((word)Addr & 1U) {               /* Not aligned address ? */
    return ERR_NOTAVAIL;               /* If no then error */
  }
  SecAddr = Addr;                      /* Address of first sector that will written */
  for (j = 0U; j < EEPROM_VIRTUAL_PAGE_SIZE; j += 0x02U) { /* Test if all words in written EEPROM area are erased */
    while (NVM_FSTAT_CCIF == 0U) {     /* Wait to command complete */
      EnterCritical();
      WDOG_CNT = 0xA602U;              /* Reset watchdog counter write 0xA602, 0xB480 */
      WDOG_CNT = 0xB480U;
      ExitCritical();
    }
    if (*(word *)(SecAddr) != 0xFFFFU) { /* Word in Flash not erased ? */
      err = EraseSectorInternal(SecAddr); /* Erase sector */
      if (err != 0U) {
        return err;                    /* Return error code if previous operation finished not correctly */
      }
    }
    SecAddr = (EEPROM_TAddress)(((word)SecAddr) + 0x02U); /* Move pointer to first word of next sector */
  }
  err = WriteBlock(Addr, 0U, EEPROM_VIRTUAL_PAGE_SIZE,(byte*)Page); /* Write the page */
  return(err);
}

/*
** ===================================================================
**     Method      :  EEPROM_GetPage (component IntEEPROM)
**     Description :
**         This method reads a page at specified EEPROM address to the
**         virtual page in RAM.
**         This method is enabled only if the <Page size> property is
**         set to a non-zero value. The method also sets address
**         pointer for <SetActByte> and <GetActByte> methods
**         (applicable only if these methods are enabled). The pointer
**         is set to address passed as the parameter + "Page size" - 1.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Addr            - Address in EEPROM
**     Returns     :
**         ---             - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_BUSY - device is busy 
**                           - ERR_RANGE - selected address out of the
**                           selected address range
** ===================================================================
*/
byte EEPROM_GetPage(EEPROM_TAddress Addr)
{
  EEPROM_TAddress SecAddr;             /* EEPROM sector address */
  byte i;                              /* Temporary variable */

  if(((word)Addr < (word)EEPROM_AREA_START) || ((word)Addr > (word)EEPROM_AREA_END)) { /* Is given address out of EEPROM area array ? */
    return ERR_RANGE;                  /* If yes then error */
  }
  if(!NVM_FSTAT_CCIF) {                /* Is reading from EEPROM possible? */
    return ERR_BUSY;                   /* If no then error */
  }
  for(i = 0U; i < EEPROM_VIRTUAL_PAGE_SIZE; i++) { /* Whole virtual page will be read */
    SecAddr = (EEPROM_TAddress)((word)Addr + i); /* new sector address */
    Page[i] = *((byte *)SecAddr);      /* Set virtual page element according to value of EEPROM given by the appropriate address */
  }
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  EEPROM_Init (component IntEEPROM)
**
**     Description :
**         Initializes the associated peripheral(s) and the component 
**         internal variables. The method is called automatically as a 
**         part of the application initialization code.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void EEPROM_Init(void)
{
  byte i;                              /* Temporary variable */

  /* NVM_FCLKDIV: FDIVLD=0,FDIVLCK=0,FDIV=7 */
  setReg8(NVM_FCLKDIV, 0x07U);          
  for(i = 0U; i < EEPROM_VIRTUAL_PAGE_SIZE; i++) { /* Fill virtual page */
    Page[i] = 0xFFU;
  }
}

/*lint -restore Enable MISRA rule (11.3,11.4) checking. */

/* END EEPROM. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.09]
**     for the Freescale HCS08 series of microcontrollers.
**
** ###################################################################
*/
